#=
Running inference simulations with `Model3SP` and
`HybridGrowthRateModel`, for data generated by `Model3SPVaryingGrowthRate` (time
varying `r` model) with different `s` values.

Inference simulations are ran in a distributed fashion; the first argument to
the script corresponds to the number of processes used.

```
julia scripts/inference_3sp/inference_3sp.jl 10
```
will run the script over 10 processes.
=#
cd(@__DIR__)
using JLD2
using DataFrames
using Random
using Dates
using ProgressMeter
using ComponentArrays
import OrdinaryDiffEq: Tsit5
using OptimizationOptimisers
using PiecewiseInference
using SciMLSensitivity
using Distributions
using Bijectors

include("../../src/utils.jl")
include("../../src/run_simulations.jl")
include("../../src/loss_fn.jl")

SYNTHETIC_DATA_PARAMS = (;p_true = ComponentArray(
                                                H = Float32[1.24, 2.5],
                                                q = Float32[4.98, 0.8],
                                                r = Float32[1.0, -0.4, -0.08],
                                                A = Float32[1.0]),
                        tsteps = range(500f0, step=4, length=100),
                        solver_params = (;alg = Tsit5(),
                                        abstol = 1e-4,
                                        reltol = 1e-4,
                                        sensealg= BacksolveAdjoint(autojacvec=ReverseDiffVJP(true)),
                                        maxiters= 50_000,
                                        verbose = false),
                        perturb = 0.5,
                        u0_true = Float32[0.77, 0.060, 0.945],)

SIMULATION_CONFIG = (;group_sizes = [5],
                    noises      = [0.1],
                    nruns       = 10,
                    ss = exp.(range(log(8f-1), log(100f-1), length = 5)))

INFERENCE_PARAMS = (;optimizers = [OptimizationOptimisers.Adam(1e-2)],
                    verbose_loss = true,
                    info_per_its = 100,
                    multi_threading = false,
                    epochs = 5000,
                    )

Random.seed!(5)

function generate_inference_params()
    return (tsteps = SYNTHETIC_DATA_PARAMS.tsteps,
            optimizers = INFERENCE_PARAMS.optimizers,
            verbose_loss = INFERENCE_PARAMS.verbose_loss,
            info_per_its = INFERENCE_PARAMS.info_per_its,
            multi_threading = INFERENCE_PARAMS.multi_threading,)
end

function generate_data()
    data_arr = []
    p_trues = []
    model = Model3SPVaryingGrowthRate(ModelParams(; u0=SYNTHETIC_DATA_PARAMS.u0_true, 
                                                    saveat=SYNTHETIC_DATA_PARAMS.tsteps,
                                                    tspan = (0.0, last(SYNTHETIC_DATA_PARAMS.tsteps)),
                                                    SYNTHETIC_DATA_PARAMS.solver_params...
                                                    ))
    for s in SIMULATION_CONFIG.ss
        ps = ComponentArray(SYNTHETIC_DATA_PARAMS.p_true; s = [s])
        data = simulate(model, p = ps ) |> Array
        push!(data_arr, data)
        push!(p_trues, ps)
    end
    data_arr, p_trues
end

function generate_df_results()
    DataFrame(group_size = Int[], 
            noise = Float64[], 
            loss = Float64[], 
            time = Float64[], 
            res = Any[], 
            adtype = Any[],
            s = Float64[],
            model = String[],
            )
end

# Initialize parameters and setup constraints
function initialize_params_and_constraints(model)
    p_true = model.mp.p
    T = eltype(p_true)
    distrib_param_arr = []
    for dp in keys(p_true)
        pair = dp => Product([Uniform(sort(T[0.25 * k, 1.75 * k])...) for k in p_true[dp]])
        push!(distrib_param_arr, pair)
    end
    
    distrib_param = NamedTuple(distrib_param_arr)
    p_bij = NamedTuple([dp => bijector(distrib_param[dp]) for dp in keys(distrib_param)])
    u0_bij = bijector(Uniform(T(1e-3), T(5e0)))  # For initial conditions
    p_init = NamedTuple([k => rand(distrib_param[k]) for k in keys(distrib_param)])
    return ComponentArray(p_init), p_bij, u0_bij
end

function initialize_params_and_constraints_hybrid_model()
    T = eltype(SYNTHETIC_DATA_PARAMS.p_true)
    perturb = SYNTHETIC_DATA_PARAMS.perturb
    distrib_param_arr = Pair{Symbol, Any}[]

    for dp in keys(SYNTHETIC_DATA_PARAMS.p_true)
        dp == :p_nn && continue
        if  dp == :r
            p = SYNTHETIC_DATA_PARAMS.p_true[dp][2:end] # the first growth rate is fitted by the neural net, but we fit r coeff for consumer and predator
        else
            p = SYNTHETIC_DATA_PARAMS.p_true[dp]
        end
        pair = dp => Product([Uniform(sort(T[(1f0-perturb/2f0) * k, (1f0+perturb/2f0) * k])...) for k in p])
        push!(distrib_param_arr, pair)
    end
    pair_nn = :p_nn => Uniform(-Inf, Inf)
    push!(distrib_param_arr, pair_nn)

    distrib_param = NamedTuple(distrib_param_arr)

    p_bij = NamedTuple([dp => bijector(distrib_param[dp]) for dp in keys(distrib_param)])
    u0_bij = bijector(Uniform(T(1e-3), T(5e0)))  # For initial conditions
    p_init = NamedTuple([k => rand(distrib_param[k]) for k in keys(distrib_param) if k !== :p_nn]) |> ComponentArray

    return p_init, p_bij, u0_bij
end

function create_simulation_parameters(data_arr, p_trues)
    group_sizes = SIMULATION_CONFIG.group_sizes
    noises = SIMULATION_CONFIG.noises
    nruns = SIMULATION_CONFIG.nruns
    adtype = Optimization.AutoZygote()

    pars_arr = Dict{Symbol,Any}[]
    for group_size in group_sizes, noise in noises, run in 1:nruns, d in 1:length(data_arr)
        u0_init = data_arr[d][:,1]
        p_true = p_trues[d]
        pref = p_true.s[1]

        # SimpleModel
        model = Model3SP(ModelParams(;p = SYNTHETIC_DATA_PARAMS.p_true,
                                    u0= u0_init,
                                    saveat = SYNTHETIC_DATA_PARAMS.tsteps,
                                    SYNTHETIC_DATA_PARAMS.solver_params...))
        p_init, p_bij, u0_bij = initialize_params_and_constraints(model)
        infprob = InferenceProblem(model, 
                                    p_init; 
                                    loss_u0_prior = LossLikelihood(), 
                                    loss_likelihood = LossLikelihood(), 
                                    p_bij, u0_bij)

        sim_params = pack_simulation_parameters(;group_size, noise, model, d, infprob, pref, adtype)
        push!(pars_arr, sim_params)

        # Hybrid model
        p_init, p_bij, u0_bij = initialize_params_and_constraints_hybrid_model()

        model = HybridGrowthRateModel(ModelParams(;p = p_init, 
                                                u0= u0_init, 
                                                saveat = SYNTHETIC_DATA_PARAMS.tsteps,
                                                SYNTHETIC_DATA_PARAMS.solver_params...),
                                                seed=run)
        infprob = InferenceProblem(model, model.mp.p; 
                                    loss_u0_prior = LossLikelihood(), 
                                    loss_likelihood = LossLikelihood(), 
                                    p_bij, u0_bij)

        sim_params = pack_simulation_parameters(;group_size, noise, model, d, infprob, pref, adtype)
        push!(pars_arr, sim_params)

    end
    return pars_arr
end

setup_distributed_environment("simul_model_selec.jl")
include("../../src/simul_model_selec.jl")
data_arr, p_trues = generate_data()
simulation_parameters = create_simulation_parameters(data_arr, p_trues);

println("Warming up...")
run_simulations([simulation_parameters[1] for p in workers()], data_arr, 10) # precompilation for std model
run_simulations([simulation_parameters[2] for p in workers()], data_arr, 10) # precompilation for omniv

println("Starting simulations...")
results = run_simulations(simulation_parameters, data_arr, INFERENCE_PARAMS.epochs)
save_results(string(@__FILE__); results, data_arr, p_trues, SYNTHETIC_DATA_PARAMS...)
